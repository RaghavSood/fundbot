// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard.sql

package db

import (
	"context"
	"time"
)

const countDistinctPairs = `-- name: CountDistinctPairs :one
SELECT COUNT(DISTINCT q.from_asset || '->' || q.to_asset) FROM topups t JOIN quotes q ON t.quote_id = q.id
`

func (q *Queries) CountDistinctPairs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDistinctPairs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDistinctProviders = `-- name: CountDistinctProviders :one
SELECT COUNT(DISTINCT provider) FROM topups
`

func (q *Queries) CountDistinctProviders(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDistinctProviders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTopups = `-- name: CountTopups :one
SELECT COUNT(*) FROM topups
`

func (q *Queries) CountTopups(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTopups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTopupsByUserID = `-- name: GetTopupsByUserID :many
SELECT t.id, t.short_id, t.type, t.quote_id, t.user_id, t.provider, t.from_chain,
       t.tx_hash, t.status, t.created_at
FROM topups t WHERE t.user_id = ? ORDER BY t.created_at DESC
`

func (q *Queries) GetTopupsByUserID(ctx context.Context, userID int64) ([]Topup, error) {
	rows, err := q.db.QueryContext(ctx, getTopupsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topup
	for rows.Next() {
		var i Topup
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Type,
			&i.QuoteID,
			&i.UserID,
			&i.Provider,
			&i.FromChain,
			&i.TxHash,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentTopups = `-- name: ListRecentTopups :many
SELECT t.id, t.short_id, t.type, t.quote_id, t.user_id, t.provider, t.from_chain,
       t.tx_hash, t.status, t.created_at,
       q.from_asset, q.to_asset, q.destination, q.input_amount_usd, q.expected_output
FROM topups t JOIN quotes q ON t.quote_id = q.id
ORDER BY t.created_at DESC LIMIT ? OFFSET ?
`

type ListRecentTopupsParams struct {
	Limit  int64
	Offset int64
}

type ListRecentTopupsRow struct {
	ID             int64
	ShortID        string
	Type           string
	QuoteID        int64
	UserID         int64
	Provider       string
	FromChain      string
	TxHash         string
	Status         string
	CreatedAt      time.Time
	FromAsset      string
	ToAsset        string
	Destination    string
	InputAmountUsd float64
	ExpectedOutput string
}

func (q *Queries) ListRecentTopups(ctx context.Context, arg ListRecentTopupsParams) ([]ListRecentTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentTopups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentTopupsRow
	for rows.Next() {
		var i ListRecentTopupsRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Type,
			&i.QuoteID,
			&i.UserID,
			&i.Provider,
			&i.FromChain,
			&i.TxHash,
			&i.Status,
			&i.CreatedAt,
			&i.FromAsset,
			&i.ToAsset,
			&i.Destination,
			&i.InputAmountUsd,
			&i.ExpectedOutput,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, telegram_id, username, created_at FROM users ORDER BY id
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TelegramID,
			&i.Username,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalVolumeUSD = `-- name: TotalVolumeUSD :one
SELECT COALESCE(SUM(q.input_amount_usd), 0) FROM topups t JOIN quotes q ON t.quote_id = q.id
`

func (q *Queries) TotalVolumeUSD(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, totalVolumeUSD)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}
