// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard.sql

package db

import (
	"context"
	"time"
)

const countDistinctPairs = `-- name: CountDistinctPairs :one
SELECT COUNT(DISTINCT q.from_asset || '->' || q.to_asset) FROM topups t JOIN quotes q ON t.quote_id = q.id
`

func (q *Queries) CountDistinctPairs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDistinctPairs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDistinctProviders = `-- name: CountDistinctProviders :one
SELECT COUNT(DISTINCT provider) FROM topups
`

func (q *Queries) CountDistinctProviders(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDistinctProviders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTopups = `-- name: CountTopups :one
SELECT COUNT(*) FROM topups
`

func (q *Queries) CountTopups(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTopups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTopupsByUserID = `-- name: GetTopupsByUserID :many
SELECT t.id, t.short_id, t.type, t.quote_id, t.user_id, t.provider, t.from_chain,
       t.tx_hash, t.status, t.created_at
FROM topups t WHERE t.user_id = ? ORDER BY t.created_at DESC
`

type GetTopupsByUserIDRow struct {
	ID        int64
	ShortID   string
	Type      string
	QuoteID   int64
	UserID    int64
	Provider  string
	FromChain string
	TxHash    string
	Status    string
	CreatedAt time.Time
}

func (q *Queries) GetTopupsByUserID(ctx context.Context, userID int64) ([]GetTopupsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopupsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopupsByUserIDRow
	for rows.Next() {
		var i GetTopupsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Type,
			&i.QuoteID,
			&i.UserID,
			&i.Provider,
			&i.FromChain,
			&i.TxHash,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentTopups = `-- name: ListRecentTopups :many
SELECT t.id, t.short_id, t.type, t.quote_id, t.user_id, t.provider, t.from_chain,
       t.tx_hash, t.status, t.created_at,
       q.from_asset, q.to_asset, q.destination, q.input_amount_usd, q.expected_output
FROM topups t JOIN quotes q ON t.quote_id = q.id
ORDER BY t.created_at DESC LIMIT ? OFFSET ?
`

type ListRecentTopupsParams struct {
	Limit  int64
	Offset int64
}

type ListRecentTopupsRow struct {
	ID             int64
	ShortID        string
	Type           string
	QuoteID        int64
	UserID         int64
	Provider       string
	FromChain      string
	TxHash         string
	Status         string
	CreatedAt      time.Time
	FromAsset      string
	ToAsset        string
	Destination    string
	InputAmountUsd float64
	ExpectedOutput string
}

func (q *Queries) ListRecentTopups(ctx context.Context, arg ListRecentTopupsParams) ([]ListRecentTopupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentTopups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentTopupsRow
	for rows.Next() {
		var i ListRecentTopupsRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.Type,
			&i.QuoteID,
			&i.UserID,
			&i.Provider,
			&i.FromChain,
			&i.TxHash,
			&i.Status,
			&i.CreatedAt,
			&i.FromAsset,
			&i.ToAsset,
			&i.Destination,
			&i.InputAmountUsd,
			&i.ExpectedOutput,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, telegram_id, username, created_at FROM users ORDER BY id
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TelegramID,
			&i.Username,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalVolumeUSD = `-- name: TotalVolumeUSD :one
SELECT COALESCE(SUM(q.input_amount_usd), 0) FROM topups t JOIN quotes q ON t.quote_id = q.id
`

func (q *Queries) TotalVolumeUSD(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, totalVolumeUSD)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const volumeByDay = `-- name: VolumeByDay :many
SELECT DATE(t.created_at) as day, COALESCE(SUM(q.input_amount_usd), 0) as total_usd, COUNT(*) as tx_count
FROM topups t JOIN quotes q ON t.quote_id = q.id
GROUP BY DATE(t.created_at) ORDER BY day
`

type VolumeByDayRow struct {
	Day      interface{}
	TotalUsd interface{}
	TxCount  int64
}

func (q *Queries) VolumeByDay(ctx context.Context) ([]VolumeByDayRow, error) {
	rows, err := q.db.QueryContext(ctx, volumeByDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolumeByDayRow
	for rows.Next() {
		var i VolumeByDayRow
		if err := rows.Scan(&i.Day, &i.TotalUsd, &i.TxCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const volumeByFromChain = `-- name: VolumeByFromChain :many
SELECT t.from_chain, COALESCE(SUM(q.input_amount_usd), 0) as total_usd, COUNT(*) as tx_count
FROM topups t JOIN quotes q ON t.quote_id = q.id
GROUP BY t.from_chain ORDER BY total_usd DESC
`

type VolumeByFromChainRow struct {
	FromChain string
	TotalUsd  interface{}
	TxCount   int64
}

func (q *Queries) VolumeByFromChain(ctx context.Context) ([]VolumeByFromChainRow, error) {
	rows, err := q.db.QueryContext(ctx, volumeByFromChain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolumeByFromChainRow
	for rows.Next() {
		var i VolumeByFromChainRow
		if err := rows.Scan(&i.FromChain, &i.TotalUsd, &i.TxCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const volumeByProvider = `-- name: VolumeByProvider :many
SELECT t.provider, COALESCE(SUM(q.input_amount_usd), 0) as total_usd, COUNT(*) as tx_count
FROM topups t JOIN quotes q ON t.quote_id = q.id
GROUP BY t.provider ORDER BY total_usd DESC
`

type VolumeByProviderRow struct {
	Provider string
	TotalUsd interface{}
	TxCount  int64
}

func (q *Queries) VolumeByProvider(ctx context.Context) ([]VolumeByProviderRow, error) {
	rows, err := q.db.QueryContext(ctx, volumeByProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolumeByProviderRow
	for rows.Next() {
		var i VolumeByProviderRow
		if err := rows.Scan(&i.Provider, &i.TotalUsd, &i.TxCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const volumeByToAsset = `-- name: VolumeByToAsset :many
SELECT q.to_asset, COALESCE(SUM(q.input_amount_usd), 0) as total_usd, COUNT(*) as tx_count
FROM topups t JOIN quotes q ON t.quote_id = q.id
GROUP BY q.to_asset ORDER BY total_usd DESC
`

type VolumeByToAssetRow struct {
	ToAsset  string
	TotalUsd interface{}
	TxCount  int64
}

func (q *Queries) VolumeByToAsset(ctx context.Context) ([]VolumeByToAssetRow, error) {
	rows, err := q.db.QueryContext(ctx, volumeByToAsset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolumeByToAssetRow
	for rows.Next() {
		var i VolumeByToAssetRow
		if err := rows.Scan(&i.ToAsset, &i.TotalUsd, &i.TxCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
